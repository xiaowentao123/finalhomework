{"version":3,"file":"index-chunk.js","sources":["../../src/network.ts","../../src/dhcp.ts","../../src/route.ts","../../src/index.ts"],"sourcesContent":["import os from 'node:os';\nimport type { GatewayAssignment, NetworkAssignment } from './types';\n\nexport const DEFAULT_ASSIGNMENT: GatewayAssignment = {\n  iname: 'lo0',\n  address: '127.0.0.1',\n  netmask: '255.0.0.0',\n  family: 'IPv4',\n  mac: '00:00:00:00:00:00',\n  internal: true,\n  cidr: '127.0.0.1/8',\n  gateway: null,\n};\n\nexport const parseMacStr = (macStr: string): number[] =>\n  macStr\n    .split(':')\n    .slice(0, 16)\n    .map(seq => parseInt(seq, 16));\n\nexport const parseIpStr = (ipStr: string): number => {\n  const addr = ipStr\n    .split('.')\n    .slice(0, 4)\n    .map(seq => parseInt(seq, 10));\n  return addr[3] | (addr[2] << 8) | (addr[1] << 16) | (addr[0] << 24);\n};\n\nexport const toIpStr = (addr: number): string => {\n  const MASK = (1 << 8) - 1;\n  let ipStr = '';\n  ipStr += `${((addr >>> 24) & MASK).toString(10)}.`;\n  ipStr += `${((addr >>> 16) & MASK).toString(10)}.`;\n  ipStr += `${((addr >>> 8) & MASK).toString(10)}.`;\n  ipStr += (addr & MASK).toString(10);\n  return ipStr;\n};\n\nconst getSubnetPriority = (addr: string): number => {\n  if (addr.startsWith('192.')) return 5;\n  else if (addr.startsWith('172.')) return 4;\n  else if (addr.startsWith('10.')) return 3;\n  else if (addr.startsWith('100.')) return 2;\n  else if (addr.startsWith('127.')) return 1;\n  else return 0;\n};\n\nexport const interfaceAssignments = (): NetworkAssignment[] => {\n  const candidates: NetworkAssignment[] = [];\n  const interfaces = os.networkInterfaces();\n  for (const iname in interfaces) {\n    const assignments = interfaces[iname];\n    if (!assignments) continue;\n    for (const assignment of assignments) {\n      if (assignment.family !== 'IPv4') continue;\n      candidates.push({ ...assignment, iname });\n    }\n  }\n  return candidates.sort((a, b) => {\n    const priorityA = getSubnetPriority(a.address);\n    const priorityB = getSubnetPriority(b.address);\n    // Prioritise external interfaces, then sort by priority,\n    // when priority is equal, sort by raw IP values\n    const sortBy =\n      +a.internal - +b.internal ||\n      priorityB - priorityA ||\n      parseIpStr(b.address) - parseIpStr(a.address);\n    return sortBy;\n  });\n};\n\nexport const matchAssignment = (\n  candidates: NetworkAssignment[],\n  addr: string\n): GatewayAssignment | null => {\n  const rawAddr = parseIpStr(addr);\n  for (const candidate of candidates) {\n    const candidateAddr = parseIpStr(candidate.address);\n    if (rawAddr === candidateAddr) return { ...candidate, gateway: null };\n    const mask = parseIpStr(candidate.netmask);\n    if ((rawAddr & mask) === (candidateAddr & mask))\n      return { ...candidate, gateway: addr };\n  }\n  return null;\n};\n","import { randomBytes } from 'node:crypto';\nimport { createSocket } from 'node:dgram';\nimport { parseIpStr, toIpStr, parseMacStr } from './network';\nimport type { NetworkAssignment } from './types';\n\nclass DHCPTimeoutError extends TypeError {\n  code = 'ETIMEDOUT';\n}\n\nconst computeBroadcastAddress = (assignment: NetworkAssignment) => {\n  const address = parseIpStr(assignment.address);\n  const netmask = parseIpStr(assignment.netmask);\n  return toIpStr(address | ~netmask);\n};\n\nconst dhcpDiscoverPacket = (macStr: string) => {\n  const MAC_ADDRESS = new Uint8Array(16);\n  MAC_ADDRESS.set(parseMacStr(macStr));\n  const packet = new Uint8Array(244);\n  const XID = randomBytes(4);\n  packet[0] = 1; // op = request\n  packet[1] = 1; // hw_type = ethernet\n  packet[2] = 6; // hw_len = ethernet\n  packet[3] = 0; // hops = 0\n  packet.set(XID, 4);\n  // elapsed = 0 seconds [2 bytes]\n  packet[10] = 0x80; // flags = broadcast discovery [2 bytes]\n  // client IP = null [4 bytes]\n  // own IP = null [4 bytes]\n  // server IP = null [4 bytes]\n  // gateway IP = null [4 bytes]\n  packet.set(MAC_ADDRESS, 28);\n  // sname = null [64 bytes]\n  // boot file = null [128 bytes]\n  packet.set([0x63, 0x82, 0x53, 0x63], 236); // Magic cookie\n  packet.set([0x35, 0x01, 0x01, 0xff], 240); // Trailer\n  return packet;\n};\n\nconst DHCP_TIMEOUT = 250;\nconst DHCP_CLIENT_PORT = 68;\nconst DHCP_SERVER_PORT = 67;\n\nexport const dhcpDiscover = (\n  assignment: NetworkAssignment\n): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const broadcastAddress = computeBroadcastAddress(assignment);\n    const packet = dhcpDiscoverPacket(assignment.mac);\n    const timeout = setTimeout(() => {\n      reject(\n        new DHCPTimeoutError(\n          `Received no reply to DHCPDISCOVER in ${DHCP_TIMEOUT}ms`\n        )\n      );\n    }, DHCP_TIMEOUT);\n    const socket = createSocket(\n      { type: 'udp4', reuseAddr: true },\n      (_msg, rinfo) => {\n        clearTimeout(timeout);\n        resolve(rinfo.address);\n        socket.close();\n        socket.unref();\n      }\n    );\n    socket.on('error', error => {\n      clearTimeout(timeout);\n      reject(error);\n      socket.close();\n      socket.unref();\n    });\n    socket.bind(DHCP_CLIENT_PORT, () => {\n      socket.setBroadcast(true);\n      socket.setSendBufferSize(packet.length);\n      socket.send(\n        packet,\n        0,\n        packet.length,\n        DHCP_SERVER_PORT,\n        broadcastAddress,\n        error => {\n          if (error) reject(error);\n        }\n      );\n    });\n  });\n};\n","import { createSocket } from 'dgram';\n\nconst NOOP_PORT = 65535;\nconst NOOP_IP = '255.255.255.255';\nconst NO_ROUTE_IP = '0.0.0.0';\n\nclass DefaultRouteError extends TypeError {\n  code = 'ECONNABORT';\n}\n\nexport const probeDefaultRoute = (): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const socket = createSocket({ type: 'udp4', reuseAddr: true });\n    socket.on('error', error => {\n      reject(error);\n      socket.close();\n      socket.unref();\n    });\n    socket.connect(NOOP_PORT, NOOP_IP, () => {\n      const address = socket.address();\n      if (address && 'address' in address && address.address !== NO_ROUTE_IP) {\n        resolve(address.address);\n      } else {\n        reject(new DefaultRouteError('No route to host'));\n      }\n      socket.close();\n      socket.unref();\n    });\n  });\n};\n","import { spawnSync } from 'child_process';\nimport { dhcpDiscover } from './dhcp';\nimport { probeDefaultRoute } from './route';\nimport {\n  DEFAULT_ASSIGNMENT,\n  interfaceAssignments,\n  matchAssignment,\n} from './network';\nimport type { GatewayAssignment } from './types';\n\nexport async function lanNetwork(): Promise<GatewayAssignment> {\n  // Get IPv4 network assignments, sorted by:\n  // - external first\n  // - LAN-reserved IP range priority\n  // - address value\n  const assignments = interfaceAssignments();\n  if (!assignments.length) {\n    // If we have no assignments (which shouldn't ever happen, we make up a loopback interface)\n    return DEFAULT_ASSIGNMENT;\n  }\n\n  let assignment: GatewayAssignment | null;\n\n  // First, we attempt to probe the default route to a publicly routed IP\n  // This will generally fail if there's no route, e.g. if the network is offline\n  try {\n    const defaultRoute = await probeDefaultRoute();\n    // If this route matches a known assignment, return it without a gateway\n    if ((assignment = matchAssignment(assignments, defaultRoute))) {\n      return assignment;\n    }\n  } catch {\n    // Ignore errors, since we have a fallback method\n  }\n\n  // Second, attempt to discover a gateway's DHCP network\n  // Because without a gateway we won't get a reply, we do this in parallel\n  const discoveries = await Promise.allSettled(\n    assignments.map(assignment => {\n      // For each assignment, we send a DHCPDISCOVER packet to its network mask\n      return dhcpDiscover(assignment);\n    })\n  );\n  for (const discovery of discoveries) {\n    // The first discovered gateway is returned, if it matches an assignment\n    if (discovery.status === 'fulfilled' && discovery.value) {\n      const dhcpRoute = discovery.value;\n      if ((assignment = matchAssignment(assignments, dhcpRoute))) {\n        return assignment;\n      }\n    }\n  }\n\n  // As a fallback, we choose the first assignment, since they're ordered by likely candidates\n  // This may return 127.0.0.1, typically as a last resort\n  return { ...assignments[0], gateway: null };\n}\n\nexport function lanNetworkSync(): GatewayAssignment {\n  const subprocessPath = require.resolve('lan-network/subprocess');\n  const { error, status, stdout } = spawnSync(\n    process.execPath,\n    [subprocessPath],\n    {\n      shell: false,\n      timeout: 500,\n      encoding: 'utf8',\n      windowsVerbatimArguments: false,\n      windowsHide: true,\n    }\n  );\n  if (status || error) {\n    return DEFAULT_ASSIGNMENT;\n  } else if (!status && typeof stdout === 'string') {\n    const json = JSON.parse(stdout.trim()) as GatewayAssignment;\n    return typeof json === 'object' && json && 'address' in json\n      ? json\n      : DEFAULT_ASSIGNMENT;\n  } else {\n    return DEFAULT_ASSIGNMENT;\n  }\n}\n"],"names":["DEFAULT_ASSIGNMENT","iname","address","netmask","family","mac","internal","cidr","gateway","parseIpStr","ipStr","addr","split","slice","map","seq","parseInt","getSubnetPriority","startsWith","interfaceAssignments","candidates","interfaces","os","networkInterfaces","assignments","assignment","push","sort","a","b","priorityA","priorityB","matchAssignment","rawAddr","candidate","candidateAddr","mask","DHCPTimeoutError","TypeError","code","dhcpDiscoverPacket","macStr","MAC_ADDRESS","Uint8Array","set","parseMacStr","packet","XID","randomBytes","dhcpDiscover","Promise","resolve","reject","broadcastAddress","MASK","toString","toIpStr","computeBroadcastAddress","timeout","setTimeout","socket","createSocket","type","reuseAddr","_msg","rinfo","clearTimeout","close","unref","on","error","bind","setBroadcast","setSendBufferSize","length","send","DefaultRouteError","probeDefaultRoute","connect","async","lanNetwork","defaultRoute","discoveries","allSettled","discovery","status","value","lanNetworkSync","subprocessPath","require","stdout","spawnSync","process","execPath","shell","encoding","windowsVerbatimArguments","windowsHide","json","JSON","parse","trim"],"mappings":";;;;;;;;;;AAGO,IAAMA,IAAwC;EACnDC,OAAO;EACPC,SAAS;EACTC,SAAS;EACTC,QAAQ;EACRC,KAAK;EACLC,WAAU;EACVC,MAAM;EACNC,SAAS;;;AASJ,IAAMC,aAAcC;EACzB,IAAMC,IAAOD,EACVE,MAAM,KACNC,MAAM,GAAG,GACTC,KAAIC,KAAOC,SAASD,GAAK;EAC5B,OAAOJ,EAAK,KAAMA,EAAK,MAAM,IAAMA,EAAK,MAAM,KAAOA,EAAK,MAAM;AAAG;;AAarE,IAAMM,oBAAqBN;EACzB,IAAIA,EAAKO,WAAW;IAAS,OAAO;SAC/B,IAAIP,EAAKO,WAAW;IAAS,OAAO;SACpC,IAAIP,EAAKO,WAAW;IAAQ,OAAO;SACnC,IAAIP,EAAKO,WAAW;IAAS,OAAO;SACpC,IAAIP,EAAKO,WAAW;IAAS,OAAO;;IACpC,OAAO;;AAAC;;AAGFC,IAAAA,uBAAuBA;EAClC,IAAMC,IAAkC;EACxC,IAAMC,IAAaC,EAAGC;EACtB,KAAK,IAAMtB,KAASoB,GAAY;IAC9B,IAAMG,IAAcH,EAAWpB;IAC/B,KAAKuB;MAAa;;IAClB,KAAK,IAAMC,KAAcD,GAAa;MACpC,IAA0B,WAAtBC,EAAWrB;QAAmB;;MAClCgB,EAAWM,KAAK;WAAKD;QAAYxB;;AACnC;AACF;EACA,OAAOmB,EAAWO,MAAK,CAACC,GAAGC;IACzB,IAAMC,IAAYb,kBAAkBW,EAAE1B;IACtC,IAAM6B,IAAYd,kBAAkBY,EAAE3B;IAOtC,QAHG0B,EAAEtB,YAAYuB,EAAEvB,YACjByB,IAAYD,KACZrB,WAAWoB,EAAE3B,WAAWO,WAAWmB,EAAE1B;AAC1B;AACb;;IAGS8B,kBAAkBA,CAC7BZ,GACAT;EAEA,IAAMsB,IAAUxB,WAAWE;EAC3B,KAAK,IAAMuB,KAAad,GAAY;IAClC,IAAMe,IAAgB1B,WAAWyB,EAAUhC;IAC3C,IAAI+B,MAAYE;MAAe,OAAO;WAAKD;QAAW1B,SAAS;;;IAC/D,IAAM4B,IAAO3B,WAAWyB,EAAU/B;IAClC,KAAK8B,IAAUG,OAAWD,IAAgBC;MACxC,OAAO;WAAKF;QAAW1B,SAASG;;;AACpC;EACA,OAAO;AAAI;;AC9Eb,MAAM0B,yBAAyBC;EAC7BC,KAAO;;;AAST,IAAMC,qBAAsBC;EAC1B,IAAMC,IAAc,IAAIC,WAAW;EACnCD,EAAYE,IDHcH,MAC1BA,EACG7B,MAAM,KACNC,MAAM,GAAG,IACTC,KAAIC,KAAOC,SAASD,GAAK,MCDZ8B,CAAYJ;EAC5B,IAAMK,IAAS,IAAIH,WAAW;EAC9B,IAAMI,IAAMC,EAAWA,YAAC;EACxBF,EAAO,KAAK;EACZA,EAAO,KAAK;EACZA,EAAO,KAAK;EACZA,EAAO,KAAK;EACZA,EAAOF,IAAIG,GAAK;EAEhBD,EAAO,MAAM;EAKbA,EAAOF,IAAIF,GAAa;EAGxBI,EAAOF,IAAI,EAAC,IAAM,KAAM,IAAM,MAAO;EACrCE,EAAOF,IAAI,EAAC,IAAM,GAAM,GAAM,OAAO;EACrC,OAAOE;AAAM;;AAOFG,IAAAA,eACXxB,KAEO,IAAIyB,SAAQ,CAACC,GAASC;EAC3B,IAAMC,IAtCuB5B,MDmBTd;IACtB,IAAM2C,IAAO;IACb,IAAI5C,IAAQ;IACZA,KAAS,IAAKC,MAAS,KAAM2C,GAAMC,SAAS;IAC5C7C,KAAS,IAAKC,MAAS,KAAM2C,GAAMC,SAAS;IAG5C,QAFA7C,KAAS,IAAKC,MAAS,IAAK2C,GAAMC,SAAS,WACjC5C,IAAO2C,GAAMC,SAAS;AACpB,ICvBLC,CAFS/C,WAAWgB,EAAWvB,YACtBO,WAAWgB,EAAWtB,UAoCXsD,CAAwBhC;EACjD,IAAMqB,IAASN,mBAAmBf,EAAWpB;EAC7C,IAAMqD,IAAUC,YAAW;IACzBP,EACE,IAAIf,iBACF;AAEH,MAfc;EAiBjB,IAAMuB,IAASC,EAAAA,aACb;IAAEC,MAAM;IAAQC,YAAW;MAC3B,CAACC,GAAMC;IACLC,aAAaR;IACbP,EAAQc,EAAM/D;IACd0D,EAAOO;IACPP,EAAOQ;AAAO;EAGlBR,EAAOS,GAAG,UAASC;IACjBJ,aAAaR;IACbN,EAAOkB;IACPV,EAAOO;IACPP,EAAOQ;AAAO;EAEhBR,EAAOW,KA/Bc,KA+BS;IAC5BX,EAAOY,cAAa;IACpBZ,EAAOa,kBAAkB3B,EAAO4B;IAChCd,EAAOe,KACL7B,GACA,GACAA,EAAO4B,QApCU,IAsCjBrB,IACAiB;MACE,IAAIA;QAAOlB,EAAOkB;;AAAM;AAE3B;AACD;;AC9EN,MAAMM,0BAA0BtC;EAC9BC,KAAO;;;AAGIsC,IAAAA,oBAAoBA,MACxB,IAAI3B,SAAQ,CAACC,GAASC;EAC3B,IAAMQ,IAASC,EAAAA,aAAa;IAAEC,MAAM;IAAQC,YAAW;;EACvDH,EAAOS,GAAG,UAASC;IACjBlB,EAAOkB;IACPV,EAAOO;IACPP,EAAOQ;AAAO;EAEhBR,EAAOkB,QAhBO,OACF,oBAeuB;IACjC,IAAM5E,IAAU0D,EAAO1D;IACvB,IAAIA,KAAW,aAAaA,KAhBd,cAgByBA,EAAQA;MAC7CiD,EAAQjD,EAAQA;;MAEhBkD,EAAO,IAAIwB,kBAAkB;;IAE/BhB,EAAOO;IACPP,EAAOQ;AAAO;AACd;;;;;;;;qBCjBCW,eAAeC;EAKpB,IAAMxD,IAAcL;EACpB,KAAKK,EAAYkD;IAEf,OAAO1E;;EAGT,IAAIyB;EAIJ;IACE,IAAMwD,UAAqBJ;IAE3B,IAAKpD,IAAaO,gBAAgBR,GAAayD;MAC7C,OAAOxD;;AAEX,IAAE,OACA;EAKF,IAAMyD,UAAoBhC,QAAQiC,WAChC3D,EAAYV,KAAIW,KAEPwB,aAAaxB;EAGxB,KAAK,IAAM2D,KAAaF;IAEtB,IAAyB,gBAArBE,EAAUC,UAA0BD,EAAUE,OAAO;MAEvD,IAAK7D,IAAaO,gBAAgBR,GADhB4D,EAAUE;QAE1B,OAAO7D;;AAEX;;EAKF,OAAO;OAAKD,EAAY;IAAIhB,SAAS;;AACvC;;yBAEO,SAAS+E;EACd,IAAMC,IAAiBC,QAAQtC,QAAQ;EACvC,KAAMmB,OAAEA,GAAKe,QAAEA,GAAMK,QAAEA,KAAWC,EAASA,UACzCC,QAAQC,UACR,EAACL,KACD;IACEM,QAAO;IACPpC,SAAS;IACTqC,UAAU;IACVC,2BAA0B;IAC1BC,cAAa;;EAGjB,IAAIZ,KAAUf;IACZ,OAAOtE;SACF,KAAKqF,KAA4B,mBAAXK,GAAqB;IAChD,IAAMQ,IAAOC,KAAKC,MAAMV,EAAOW;IAC/B,OAAuB,mBAATH,KAAqBA,KAAQ,aAAaA,IACpDA,IACAlG;AACN;IACE,OAAOA;;AAEX;;;;"}